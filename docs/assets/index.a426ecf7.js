import{_ as i}from"./ButtonSection.d2110d16.js";import{C as r,d as e,e as o,f as n,g as s,k as a,l as k,i as l,u as m}from"./vendor.c6d6bfe0.js";import"./app.19bd1e91.js";const h={class:"prose prose-sm m-auto text-left"},d=n("h1",null,"Breadth-first search algorithm and applications",-1),g=n("h3",null,"1) Breadth-first search algorithms",-1),w=n("p",null,"Breadth-first search algorithm give the distance between a given node to all the other node belonging to the same component.",-1),y=n("h4",null,[s("1. "),n("em",null,"Naive"),s(" implementation")],-1),_=n("p",null,[s("The first implementation we use is "),n("em",null,"\u201Cnaive\u201D"),s(" and use the following principles:")],-1),b=n("p",null,[s("Let "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])])]),s(" = number of nodes.")],-1),f=n("p",null,[s("Let "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"m")]),n("annotation",{encoding:"application/x-tex"},"m")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"m")])])])]),s(" = number of edges.")],-1),x=n("p",null,[s("Let "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"i")]),n("annotation",{encoding:"application/x-tex"},"i")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6595em"}}),n("span",{class:"mord mathnormal"},"i")])])])]),s(" = studied node.")],-1),v=n("p",null,[s("Let "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"s")]),n("annotation",{encoding:"application/x-tex"},"s")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"s")])])])]),s(" = destination node.")],-1),M=n("p",null,[s("Let "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d")]),n("annotation",{encoding:"application/x-tex"},"d")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal"},"d")])])])]),s(" = number of rounds.")],-1),q=n("p",null,[n("strong",null,"1/"),s(" Creation of an array "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"D"),n("mi",null,"s")])]),n("annotation",{encoding:"application/x-tex"},"D_{s}")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.1514em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"s")])])])]),n("span",{class:"vlist-s"},"\u200B")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])])]),s(" of "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"n")]),n("annotation",{encoding:"application/x-tex"},"n")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4306em"}}),n("span",{class:"mord mathnormal"},"n")])])])]),s(" integers to store the distances "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d"),n("mo",{stretchy:"false"},"("),n("mi",null,"i"),n("mo",{separator:"true"},","),n("mi",null,"s"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"d(i,s)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mpunct"},","),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mclose"},")")])])])]),s(".")],-1),L=n("p",null,[n("strong",null,"2/"),s(" Initialization of "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"D"),n("mi",null,"s")])]),n("annotation",{encoding:"application/x-tex"},"D_{s}")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.1514em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"s")])])])]),n("span",{class:"vlist-s"},"\u200B")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])])])])])]),s(" : "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",{mathvariant:"normal"},"\u2200"),n("mtext",null,"\xA0"),n("mi",null,"i"),n("mo",{mathvariant:"normal"},"\u2260"),n("mi",null,"s"),n("mtext",null,"\xA0"),n("mo",{separator:"true"},","),n("mtext",null,"\xA0"),n("msub",null,[n("mi",null,"D"),n("mi",null,"s")]),n("mo",{stretchy:"false"},"("),n("mi",null,"i"),n("mo",{stretchy:"false"},")"),n("mo",null,"="),n("mo",null,"\u2212"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"\\forall \\ i \\neq s \\ , \\ D_{s}(i)=-1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),n("span",{class:"mord"},"\u2200"),n("span",{class:"mspace"},"\xA0"),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},[n("span",{class:"mrel"},[n("span",{class:"mord vbox"},[n("span",{class:"thinbox"},[n("span",{class:"rlap"},[n("span",{class:"strut",style:{height:"0.8889em","vertical-align":"-0.1944em"}}),n("span",{class:"inner"},[n("span",{class:"mord"},[n("span",{class:"mrel"},"\uE020")])]),n("span",{class:"fix"})])])])]),n("span",{class:"mrel"},"=")]),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"s"),n("span",{class:"mspace"},"\xA0"),n("span",{class:"mpunct"},","),n("span",{class:"mspace"},"\xA0"),n("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.1514em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"s")])])])]),n("span",{class:"vlist-s"},"\u200B")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mclose"},")"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),n("span",{class:"mord"},"\u2212"),n("span",{class:"mord"},"1")])])])]),s(" else "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("msub",null,[n("mi",null,"D"),n("mi",null,"s")]),n("mo",{stretchy:"false"},"("),n("mi",null,"i"),n("mo",{stretchy:"false"},")"),n("mo",null,"="),n("mn",null,"0")]),n("annotation",{encoding:"application/x-tex"},"D_{s}(i) = 0")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord"},[n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),n("span",{class:"msupsub"},[n("span",{class:"vlist-t vlist-t2"},[n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.1514em"}},[n("span",{style:{top:"-2.55em","margin-left":"-0.0278em","margin-right":"0.05em"}},[n("span",{class:"pstrut",style:{height:"2.7em"}}),n("span",{class:"sizing reset-size6 size3 mtight"},[n("span",{class:"mord mtight"},[n("span",{class:"mord mathnormal mtight"},"s")])])])]),n("span",{class:"vlist-s"},"\u200B")]),n("span",{class:"vlist-r"},[n("span",{class:"vlist",style:{height:"0.15em"}},[n("span")])])])])]),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"i"),n("span",{class:"mclose"},")"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"0")])])])]),s(".")],-1),D=n("p",null,[n("strong",null,"3/"),s(" Find all nodes with distance "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d")]),n("annotation",{encoding:"application/x-tex"},"d")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal"},"d")])])])]),s(". If there is no, then stop.")],-1),T=n("p",null,[n("strong",null,"4/"),s(" Find the neighbors of these nodes, assign those neighbors which don\u2019t have a distance yet, with the distance "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d"),n("mo",null,"+"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"d + 1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])])]),s(".")],-1),j=n("p",null,[n("strong",null,"5/"),s(" Set "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"d"),n("mo",null,"="),n("mi",null,"d"),n("mo",null,"+"),n("mn",null,"1")]),n("annotation",{encoding:"application/x-tex"},"d = d + 1")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6944em"}}),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),n("span",{class:"mrel"},"="),n("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.0833em"}}),n("span",{class:"mord mathnormal"},"d"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.6444em"}}),n("span",{class:"mord"},"1")])])])]),s(" and go to "),n("strong",null,"3/"),s(".")],-1),z=a(`<p>Below is a R implementation:</p><pre class="language-r"><code class="language-r">breadth_first <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  k <span class="token operator">&lt;-</span> nrow<span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
  outvect <span class="token operator">&lt;-</span> vector<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">&quot;numeric&quot;</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> node <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      outvect<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
      outvect<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  end <span class="token operator">&lt;-</span> <span class="token boolean">FALSE</span>
  d <span class="token operator">&lt;-</span> <span class="token number">0</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span> end <span class="token operator">==</span> <span class="token boolean">FALSE</span>  <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    positivecondition <span class="token operator">&lt;-</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span> outvect<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span> d<span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        positivecondition<span class="token punctuation">[</span>length<span class="token punctuation">(</span>positivecondition<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token punctuation">(</span>positivecondition<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      end <span class="token operator">&lt;-</span> <span class="token boolean">TRUE</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>length<span class="token punctuation">(</span>positivecondition<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>areneighbours<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>positivecondition<span class="token punctuation">[</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">TRUE</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>outvect<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
            outvect<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;-</span> d <span class="token operator">+</span> <span class="token number">1</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    d <span class="token operator">&lt;-</span> d <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
  outvect
<span class="token punctuation">}</span>
</code></pre><p>With the details of the <code>areneighbours</code> function bellow.</p><pre class="language-r"><code class="language-r">areneighbours <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span> is.vector<span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">TRUE</span> <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    matinput <span class="token operator">&lt;-</span> fromListToMatrice<span class="token punctuation">(</span>input<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>matinput<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      output <span class="token operator">&lt;-</span> <span class="token boolean">TRUE</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span>
    <span class="token punctuation">{</span>
      output <span class="token operator">&lt;-</span> <span class="token boolean">FALSE</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span> is.matrix<span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">TRUE</span> <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>input<span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      output <span class="token operator">&lt;-</span> <span class="token boolean">TRUE</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span>
    <span class="token punctuation">{</span>
      output <span class="token operator">&lt;-</span> <span class="token boolean">FALSE</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  output
<span class="token punctuation">}</span>
</code></pre>`,4),S=n("p",null,[s("The way we implement this could be better executed (notably the with the "),n("code",null,"areneighbours"),s(") but with this algorithm, for a typical network, complexity is "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"m"),n("mo",null,"+"),n("mi",null,"n"),n("mo",null,"\u2217"),n("mi",null,"l"),n("mi",null,"o"),n("mi",null,"g"),n("mo",{stretchy:"false"},"("),n("mi",null,"n"),n("mo",{stretchy:"false"},")"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(m + n *log(n))")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"m"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"0.4653em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"\u2217"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),n("span",{class:"mord mathnormal"},"o"),n("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},"))")])])])]),s(".")],-1),B=a(`<h4>2. <em><strong>Stack</strong></em> implementation</h4><p>A better implementation could be done with using a queue. Here is a implementation with the stack algorithm:</p><pre class="language-r"><code class="language-r">breadth_first_stack <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  aplist <span class="token operator">&lt;-</span> fromMatriceToList<span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
  stack <span class="token operator">&lt;-</span> vector<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">&quot;numeric&quot;</span><span class="token punctuation">)</span>
  stack<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span> node
  read <span class="token operator">&lt;-</span> <span class="token number">1</span>
  write <span class="token operator">&lt;-</span> <span class="token number">2</span>
  k <span class="token operator">&lt;-</span> nrow<span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
  ds <span class="token operator">&lt;-</span> vector<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">&quot;numeric&quot;</span><span class="token punctuation">,</span>k<span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> i <span class="token operator">==</span> node <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      ds<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span><span class="token punctuation">{</span>
      ds<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>read <span class="token operator">!=</span> write<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>length<span class="token punctuation">(</span>aplist<span class="token punctuation">[</span><span class="token punctuation">[</span>stack<span class="token punctuation">[</span>read<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>ds<span class="token punctuation">[</span> aplist<span class="token punctuation">[</span><span class="token punctuation">[</span>stack<span class="token punctuation">[</span>read<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        ds<span class="token punctuation">[</span> aplist<span class="token punctuation">[</span><span class="token punctuation">[</span>stack<span class="token punctuation">[</span>read<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token operator">&lt;-</span> ds<span class="token punctuation">[</span> stack<span class="token punctuation">[</span>read<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        stack<span class="token punctuation">[</span>write<span class="token punctuation">]</span> <span class="token operator">&lt;-</span> aplist<span class="token punctuation">[</span><span class="token punctuation">[</span>stack<span class="token punctuation">[</span>read<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        write <span class="token operator">&lt;-</span> write <span class="token operator">+</span><span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    read <span class="token operator">&lt;-</span> read <span class="token operator">+</span> <span class="token number">1</span> 
  <span class="token punctuation">}</span>
  ds
<span class="token punctuation">}</span>
</code></pre>`,3),E=n("p",null,[s("With the stack approach the complexity is smaller: "),n("eq",null,[n("span",{class:"katex"},[n("span",{class:"katex-mathml"},[n("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[n("semantics",null,[n("mrow",null,[n("mi",null,"O"),n("mo",{stretchy:"false"},"("),n("mi",null,"m"),n("mo",null,"+"),n("mi",null,"n"),n("mo",{stretchy:"false"},")")]),n("annotation",{encoding:"application/x-tex"},"O(m + n)")])])]),n("span",{class:"katex-html","aria-hidden":"true"},[n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),n("span",{class:"mopen"},"("),n("span",{class:"mord mathnormal"},"m"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),n("span",{class:"mbin"},"+"),n("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),n("span",{class:"base"},[n("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),n("span",{class:"mord mathnormal"},"n"),n("span",{class:"mclose"},")")])])])])],-1),R=a(`<p>For this tow approach we have the result of a unique node. To have the complete matrices of distance as required in Q1, we repeat the operation for all nodes and aggregate the outputs. This is the purpose of the <code>mat_D_breadth_first_stack</code> function using the stack algorithm.</p><pre class="language-r"><code class="language-r">mat_D_breadth_first_stack <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  k <span class="token operator">&lt;-</span> nrow<span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
  outputmat <span class="token operator">&lt;-</span> vector<span class="token punctuation">(</span>mode <span class="token operator">=</span> <span class="token string">&quot;numeric&quot;</span><span class="token punctuation">)</span>

  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    outputmat <span class="token operator">&lt;-</span> c<span class="token punctuation">(</span>outputmat<span class="token punctuation">,</span>breadth_first_stack<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  dim<span class="token punctuation">(</span>outputmat<span class="token punctuation">)</span> <span class="token operator">&lt;-</span> c<span class="token punctuation">(</span>k<span class="token punctuation">,</span>k<span class="token punctuation">)</span>
  outputmat
<span class="token punctuation">}</span>
</code></pre><h3>2) Diameter</h3><p>Diameter is a record of the largest distance observed in a component. Once the Breadth-first search executed, finding the diameter for a given node is straightforward.</p><pre class="language-r"><code class="language-r">diammeter <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  k <span class="token operator">&lt;-</span> nrow<span class="token punctuation">(</span>input_mat<span class="token punctuation">)</span>
  bfs_node <span class="token operator">&lt;-</span> breadth_first_stack<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  diameter <span class="token operator">&lt;-</span> max<span class="token punctuation">(</span>bfs_node<span class="token punctuation">)</span>
  lst_compenent_memeber <span class="token operator">&lt;-</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>bfs_node<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      lst_compenent_memeber<span class="token punctuation">[</span><span class="token punctuation">[</span>length<span class="token punctuation">(</span>lst_compenent_memeber<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span> i
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  l <span class="token operator">&lt;-</span> length<span class="token punctuation">(</span>lst_compenent_memeber<span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>l<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> max<span class="token punctuation">(</span>breadth_first_stack<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>lst_compenent_memeber<span class="token punctuation">[</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> diameter <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      diameter <span class="token operator">&lt;-</span> max<span class="token punctuation">(</span>breadth_first_stack<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>lst_compenent_memeber<span class="token punctuation">[</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  diameter
<span class="token punctuation">}</span>
</code></pre><h3>3) Closeness centrality</h3><p>First, we have to underline that if the network is not composed of a single unique component, the result of the closeness centrality must be taken with care. It is possible to handle each component individually, but this can bias the values. Indeed, nodes in smaller component may have higher value. This is what the following example do:</p><pre class="language-r"><code class="language-r">closeness_centrality_node <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span> input_mat <span class="token punctuation">,</span> node <span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  dist <span class="token operator">&lt;-</span> breadth_first_stack_list<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
  n <span class="token operator">&lt;-</span> length<span class="token punctuation">(</span>dist<span class="token punctuation">)</span>
  sum <span class="token operator">&lt;-</span> <span class="token number">0</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>n<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> dist<span class="token punctuation">[</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token comment">#Here nodes that are not in the component are not take in account.faire la remarque page 47 (A modfifier ?)</span>
    <span class="token punctuation">{</span>
      sum <span class="token operator">&lt;-</span> sum <span class="token operator">+</span> dist<span class="token punctuation">[</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  output <span class="token operator">&lt;-</span> length<span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
  output
<span class="token punctuation">}</span>
</code></pre><p>We use the very inelegant (but functional) breadth_first_stack_list function described below.</p><pre class="language-r"><code class="language-r">breadth_first_stack_list <span class="token operator">&lt;-</span> <span class="token keyword">function</span><span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  output_vect <span class="token operator">&lt;-</span> breadth_first_stack<span class="token punctuation">(</span>input_mat<span class="token punctuation">,</span>node<span class="token punctuation">)</span>
  k <span class="token operator">&lt;-</span> length<span class="token punctuation">(</span>output_vect<span class="token punctuation">)</span>
  output_list <span class="token operator">&lt;-</span> list<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">:</span>k<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>output_vect<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      output_list<span class="token punctuation">[</span><span class="token punctuation">[</span>length<span class="token punctuation">(</span>output_list<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span>  output_vect<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  output_list
<span class="token punctuation">}</span>
</code></pre><p>Note that the igraph package throw a warning when the components are not all linked together. /!\\ Quel fonction donner un example etc\u2026</p><h3>4) Betweennes centrality</h3><p>Implementing the Betweennes centrality was the hardest task to complete. Finding all the shortest path is the blocking point. I tried to do this job with a recusive function knowing the lenght of every shortest path with a previous breadfirst search. Unfortunately I did not maneged to make this function work. <s>The following programm visit all the nodes, but returning the target point and aggregate the coresting path is not so easy.</s></p>`,13),F=[d,g,w,y,_,b,f,x,v,M,q,L,D,T,j,z,S,B,E,R],I={setup(c,{expose:t}){return t({frontmatter:{meta:[]}}),r({meta:[]}),(O,U)=>(e(),o("div",h,F))}},N={class:"allContent text-center"},H=k({setup(c){return(t,u)=>{const p=i;return e(),o("div",N,[l(m(I),{class:"md"}),l(p,{nextSectionName:"Igraph package",nextRoute:"/complexSystem/getting-started/igraph-package",previousSectionName:"Representations of graph and first metrics",previousRoute:"/complexSystem/getting-started/representations-of-graph-and-first-metrics"})])}}});export{H as default};
